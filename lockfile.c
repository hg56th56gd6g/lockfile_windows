#include "lockfile.h"
void main(void){
    HANDLE stdi;
    TempDataStruct *data;
    //因为没有stdo句柄,所以直接退出
    if(!(
        //初始化内存分配,将临时的变量放在新创建的堆,解析完成后等待用户关闭的时候销毁堆,正常free内存占用不会完全释放,这保证了等待控制台输入(即已经锁定文件等待用户关闭程序时)的低内存占用
        (stdi=HeapCreate(HEAP_NO_SERIALIZE,0,0))&&
        (data=HeapAlloc(stdi,0,sizeof(TempDataStruct)))&&
        //加载ntdll.dll和函数
        (ntdl=LoadLibraryA("ntdll"))&&
        (NtReadFile=(PNtReadFile)GetProcAddress(ntdl,"NtReadFile"))&&
        (NtOpenFile=(PNtOpenFile)GetProcAddress(ntdl,"NtOpenFile"))&&
        //获取stdo句柄
        ((stdo=GetStdHandle(STD_OUTPUT_HANDLE))!=INVALID_HANDLE_VALUE)
    )){return;}
    //将创建的堆的句柄复制到临时区
    heap=stdi;
    //BuildBy hg56th56gd6g
    WriteFile(stdo,"BuildBy hg56th56gd6g\n\n",22,&temp,0);
    //获取stdi句柄失败
    if((stdi=GetStdHandle(STD_INPUT_HANDLE))==INVALID_HANDLE_VALUE){
        WriteFile(stdo,"StdInputErr",11,&temp,0);
        return;
    }
    //设置i模式(无输入缓冲,用于按任意键继续)
    SetConsoleMode(stdi,0);
    //填充ObjectAttributes,之后不再改变,几个规则:不区分大小写;
    obja.Length=sizeof(OBJECT_ATTRIBUTES);
    obja.RootDirectory=0;
    obja.ObjectName=&ustr;
    obja.Attributes=OBJ_CASE_INSENSITIVE;
    obja.SecurityDescriptor=0;
    obja.SecurityQualityOfService=0;
    //填充Path,之后除了Length不再改变
    ustr.MaximumLength=65535;
    ustr.Buffer=(PWSTR)&path;
    //NtOpenFile/NtCreateFile的对象名称是"\DosDevices\[FilePath(c:\Windows\...)]"或"\Device\[设备名,例如HarddiskVolume1]\[FilePath(Windows\...)]"这里用第一种
    path[0]='\\';path[1]=0;path[2]='D';path[3]=0;path[4]='o';path[5]=0;path[6]='s';path[7]=0;path[8]='D';path[9]=0;path[10]='e';path[11]=0;path[12]='v';path[13]=0;path[14]='i';path[15]=0;path[16]='c';path[17]=0;path[18]='e';path[19]=0;path[20]='s';path[21]=0;path[22]='\\';path[23]=0;
    if(!(
        //获取完整路径
        (plen=24+((GetFullPathNameW(L"file.list",32755,(LPWSTR)&buff,0))<<1))&&
        //打开file.list,几个规则:只读数据(不能读属性,扩展属性等);独占文件;顺序操作;同步操作;文件不是目录
        (NtOpenFile(&file,FILE_READ_DATA|SYNCHRONIZE,&obja,&iosb,0,FILE_SEQUENTIAL_ONLY|FILE_SYNCHRONOUS_IO_NONALERT|FILE_NON_DIRECTORY_FILE)==STATUS_SUCCESS)&&
        (iosb.Status==STATUS_SUCCESS)&&
        (iosb.Information==FILE_OPENED)
    )){
        //打开失败
        WriteFile(stdo,"OpenErr",7,&temp,0);
        goto ends;
    }
    //解析,结构为{[uint16le路径长度(0-65511)][路径(绝对路径,unicode)]}*
    for(;;){
        //读2字节并设置plen
        stts=NtReadFile(file,0,0,0,&iosb,&buff,2,0,0);
        //读完了
        if(
            (stts==STATUS_END_OF_FILE)||
            (iosb.Status==STATUS_END_OF_FILE)
        ){
            WriteFile(stdo,"\nok",3,&temp,0);
            goto ends;
        }
        //读到了
        if(
            (stts==STATUS_SUCCESS)&&
            (iosb.Status==STATUS_SUCCESS)
        ){
            //判断是否读到2字节
            if(iosb.Information==2){
                plen=buff[0]+(buff[1]<<8);
                //检查plen并读plen字节
                if(
                    (plen<=65511)&&
                    (NtReadFile(file,0,0,0,&iosb,&buff,plen,0,0)==STATUS_SUCCESS)&&
                    (iosb.Status==STATUS_SUCCESS)&&
                    (iosb.Information==plen)
                ){
                    //打印路径并把plen加上L"\\DosDevices\\"的长度
                    WriteFile(stdo,&buff,plen,&temp,0);
                    plen+=24;
                    //打开路径,几个规则:拥有所有权限(如果没有权限,即使没有设置分享权限,也不能独占);独占文件;
                    if(
                        (NtOpenFile(&hand,FILE_ALL_ACCESS,&obja,&iosb,0,0)==STATUS_SUCCESS)&&
                        (iosb.Status==STATUS_SUCCESS)&&
                        (iosb.Information==FILE_OPENED)
                    ){
                        //打开成功
                        WriteFile(stdo,"|T\n",3,&temp,0);
                        continue;
                    }
                    //打开失败
                    WriteFile(stdo,"|F\n",3,&temp,0);
                    continue;
                }
            }
        }
        //读file.list失败或格式错误
        WriteFile(stdo,"\nReadErr",8,&temp,0);
        goto ends;
    }
    //PressAnyKeyToExit
    ends:
    WriteFile(stdo,"\nPressAnyKeyToExit",18,&temp,0);
    //销毁储存临时变量的堆
    HeapDestroy(heap);
    //按任意键继续
    ReadFile(stdi,(LPVOID)&data,1,(LPDWORD)&data,0);
}