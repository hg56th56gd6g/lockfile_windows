#include "lockfile.h"
#include <stdio.h>
void main(void){
    TempDataStruct *data;
    //因为没有stdo句柄,所以直接退出
    if(!(
        //初始化内存分配,私有的无缓存页面区域
        (data=VirtualAlloc(0,sizeof(TempDataStruct),MEM_COMMIT|MEM_RESERVE,PAGE_EXECUTE_READWRITE|PAGE_NOCACHE))&&
        //加载ntdll.dll和函数
        (ntdl=LoadLibraryA("ntdll"))&&
        (NtReadFile=(PNtReadFile)GetProcAddress(ntdl,"NtReadFile"))&&
        (NtOpenFile=(PNtOpenFile)GetProcAddress(ntdl,"NtOpenFile"))&&
        (NtClose=(PNtClose)GetProcAddress(ntdl,"NtClose"))&&
        //获取stdo句柄
        ((stdo=GetStdHandle(STD_OUTPUT_HANDLE))!=INVALID_HANDLE_VALUE)
    )){ExitProcess(0);}
    //BuildBy hg56th56gd6g
    WriteFile(stdo,"BuildBy hg56th56gd6g\n",21,&none,0);
    //填充ObjectAttributes,之后不再改变,几个规则:不区分大小写;
    obja.Length=sizeof(OBJECT_ATTRIBUTES);
    obja.RootDirectory=0;
    obja.ObjectName=&ustr;
    obja.Attributes=OBJ_CASE_INSENSITIVE;
    obja.SecurityDescriptor=0;
    obja.SecurityQualityOfService=0;
    //填充Path,之后除了Length不再改变
    ustr.MaximumLength=65535;
    ustr.Buffer=(PWSTR)&path;
    //NtOpenFile/NtCreateFile的对象名称是"\DosDevices\[FilePath(c:\Windows\...)]"或"\Device\[设备名,例如HarddiskVolume1]\[FilePath(Windows\...)]"这里用第一种
    path[0]='\\';path[1]=0;path[2]='D';path[3]=0;path[4]='o';path[5]=0;path[6]='s';path[7]=0;path[8]='D';path[9]=0;path[10]='e';path[11]=0;path[12]='v';path[13]=0;path[14]='i';path[15]=0;path[16]='c';path[17]=0;path[18]='e';path[19]=0;path[20]='s';path[21]=0;path[22]='\\';path[23]=0;
    if(!(
        //获取完整路径
        (plen=24+((GetFullPathNameW(L"file.list",32755,(LPWSTR)&buff,0))<<1))&&
        //打开file.list,几个规则:只读数据(不能读属性,扩展属性等);独占文件;顺序操作;同步操作;文件不是目录
        (NtOpenFile(&file,FILE_READ_DATA|SYNCHRONIZE,&obja,&iosb,0,FILE_SEQUENTIAL_ONLY|FILE_SYNCHRONOUS_IO_NONALERT|FILE_NON_DIRECTORY_FILE)==STATUS_SUCCESS)&&
        (iosb.Status==STATUS_SUCCESS)&&
        (iosb.Information==FILE_OPENED)
    )){
        //打开失败
        WriteFile(stdo,"OpenErr",7,&none,0);
        goto end0;
    }
    //解析,结构为{[uint16le路径长度(0-65511)][路径(绝对路径,unicode)]}*
    for(;;){
        //读2字节并设置plen
        stts=NtReadFile(file,0,0,0,&iosb,&buff,2,0,0);
        //读完了
        if(
            (stts==STATUS_END_OF_FILE)||
            (iosb.Status==STATUS_END_OF_FILE)
        ){
            WriteFile(stdo,"\nOK",3,&none,0);
            goto end1;
        }
        //读到了
        if(
            (stts==STATUS_SUCCESS)&&
            (iosb.Status==STATUS_SUCCESS)
        ){
            //判断是否读到2字节
            if(iosb.Information==2){
                plen=buff[0]+(buff[1]<<8);
                //检查plen并读plen字节
                if(
                    (plen<=65511)&&
                    (NtReadFile(file,0,0,0,&iosb,&buff,plen,0,0)==STATUS_SUCCESS)&&
                    (iosb.Status==STATUS_SUCCESS)&&
                    (iosb.Information==plen)
                ){
                    //把plen加上L"\\DosDevices\\"的长度
                    plen+=24;
                    //打开路径,几个规则:拥有所有权限(如果没有权限,即使没有设置分享权限,也不能独占);独占文件;
                    if(
                        (NtOpenFile(&hand,FILE_ALL_ACCESS,&obja,&iosb,0,0)==STATUS_SUCCESS)&&
                        (iosb.Status==STATUS_SUCCESS)&&
                        (iosb.Information==FILE_OPENED)
                    ){
                        //打开成功
                        WriteFile(stdo,"T",1,&none,0);
                        continue;
                    }
                    //打开失败
                    WriteFile(stdo,"F",1,&none,0);
                    continue;
                }
            }
        }
        //读file.list失败或格式错误
        WriteFile(stdo,"\nReadErr",8,&none,0);
    }
    //WaitForExit
    end1:
    NtClose(file);
    end0:
    WriteFile(stdo,"\nWaitForExit",12,&none,0);
    //释放储存临时数据的页面区域
    VirtualFree(data,0,MEM_RELEASE);
    //删除尽可能多的页面,并使工作集大小可以低于最低,不能超过最高
    SetProcessWorkingSetSizeEx(GetCurrentProcess(),(SIZE_T)-1,(SIZE_T)-1,QUOTA_LIMITS_HARDWS_MIN_DISABLE|QUOTA_LIMITS_HARDWS_MAX_ENABLE);
    //挂起
    SuspendThread(GetCurrentThread());
    ExitProcess(0);
}